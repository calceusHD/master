So this is the code for my master thesis. You sould probably read that before trying to understand my code.

My first implementation was completely in python and not exploiting qc structure. Just a simple encoder and message passing deocer. These are in the top level files codec_test.py, encody.py, decode.py. Also there is greedy_alg_a.py that implements an algorithm to archieve the lower triangular form. This works but the results are not pretty. And the algorithm also is not deterministic.

The next one is basically in the sames files but most of the functions are prefixed with qc_. These represent my idea of the hardware code I wanted to write. So the two part iteration and all that is in there. 

Lastly I have the python that generates the vhdl code. The simpled ones are in encoder_gen, encoder_fast_gen decoder_base_gen, and decoder_soft_base_gen these are just a test to see if i'm capable of writing a simple message passing decoder. The supporting vhdl code is in /vhdl/ all files generated are in /vhd/autogen/ the files there are written by the python. decoder_base_gen is a hard decoder so one bit per element. The soft one features adjustable llr bit width. In these files mostly at the top is the PCM hardcoded. My plan was to keep the PCM in some kind of configuration file but i didn't have time to do that so they are mostly hardcoded. I think in all the files the raw PCM is called H. I'm not shure how well this non QC code works right now but at some point in history they were wokring. 

Main part of my work is the stuff that has qc in it's name. A large part of that is qc_decoder_gen.py. In this file all configuration is set. In these qc files the base matrix is mostly named Hqc. At the top are some different commented out codes for testing. Also important is block_size and block_vector. These as the names say are the size of the submatrices in the PCM and block_vector is the first row of the submatrix. In theory it should be possible to use this to specify any cyclic matrix for my code. But probably it is best to keep the vector [1, 0, 0, ....]. This is what my code is tested with. 

The vhdl code for the qc stuff is in /vhdl/QC/ there is also the autogenerated file generated_common.vhd this is built by the python script. The other files are my vhdl implementation. Of interest is maybe the min_mangle entity. This is the place the you would implement any algorithm that changes the minimum. Currently there is just one multiplication but you could also subtract some fixed value there. val_1 and val_2 are external parameters that can be set by the gpio blocks from the cpu. hard_cn_res is the current output of the active row with its parity check equation. You could use that to implement the adaptive min sum that is explained in my thesis. Otherwise fsm.vhd is the control logic. It has a state machine that controls if we are currently working or are waiting to work. The other thing it does is reading the instructions generated by the python script from rom. The rom is called INSTRUCTIONS and defined in the autogenerated file. In case you want to do some reconfiguration the easiest way would be to replace this rom with some memory that can interface in some way to the arm cpu. Depending on the input, intermediate, and output memory you could basically implement any PCM with the same block size with it. You should change the memory sized in the python generation script accordingly to match the maximum matrix you expect. One problem though is the bit_repack entity. This one takes a densely packed stream of data that only missing bits at the end. And outputs all data continously. If the sizes don't really match you have to set the LAST_WORD_PADDING so that it fits the size of the bits that remain in the last word. The predefined values are calculated by the python script. You can look into the calculation there to find out whats values are required.
